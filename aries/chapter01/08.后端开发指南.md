# 08. åç«¯å¼€å‘æŒ‡å—

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜äº†æ—…æ¸¸æœåŠ¡ç³»ç»Ÿåç«¯å¼€å‘çš„è§„èŒƒã€API è®¾è®¡å’Œæ•°æ®åº“æ“ä½œã€‚

## ğŸ› ï¸ æŠ€æœ¯æ ˆ

### æ ¸å¿ƒæ¡†æ¶
- **Next.js 16**: æä¾›å…¨æ ˆåŠŸèƒ½
- **API Routes**: RESTful API å®ç°
- **Server Actions**: æœåŠ¡ç«¯æ“ä½œ

### æ•°æ®åº“
- **SQLite**: è½»é‡çº§æ–‡ä»¶æ•°æ®åº“
- **better-sqlite3**: é«˜æ€§èƒ½ Node.js SQLite é©±åŠ¨

### è®¤è¯ä¸å®‰å…¨
- **JWT**: æ— çŠ¶æ€è®¤è¯
- **bcryptjs**: å¯†ç å“ˆå¸Œ
- **Zod**: æ•°æ®éªŒè¯

## ğŸ“ API è·¯ç”±ç»“æ„

```
app/api/
â”œâ”€â”€ auth/              # è®¤è¯ç›¸å…³
â”‚   â”œâ”€â”€ login/         # ç™»å½•
â”‚   â”œâ”€â”€ register/      # æ³¨å†Œ
â”‚   â””â”€â”€ me/           # å½“å‰ç”¨æˆ·
â”œâ”€â”€ spots/            # æ™¯ç‚¹ç®¡ç†
â”‚   â”œâ”€â”€ [id]/         # æ™¯ç‚¹è¯¦æƒ…
â”‚   â”‚   â”œâ”€â”€ comments/ # è¯„è®º
â”‚   â”‚   â”œâ”€â”€ like/     # ç‚¹èµ
â”‚   â”‚   â””â”€â”€ favorite/ # æ”¶è—
â”‚   â””â”€â”€ route.ts      # åˆ—è¡¨å’Œåˆ›å»º
â”œâ”€â”€ categories/       # åˆ†ç±»ç®¡ç†
â”œâ”€â”€ users/           # ç”¨æˆ·ç®¡ç†
â”œâ”€â”€ cart/            # è´­ç‰©è½¦
â”œâ”€â”€ orders/          # è®¢å•ç®¡ç†
â”œâ”€â”€ hotels/          # é…’åº—ç®¡ç†
â”œâ”€â”€ activities/      # æ´»åŠ¨ç®¡ç†
â””â”€â”€ news/           # æ–°é—»ç®¡ç†
```

## ğŸ”§ æ•°æ®åº“é…ç½®

### 1. æ•°æ®åº“è¿æ¥

```typescript
// lib/db.ts
import Database from 'better-sqlite3'
import { join } from 'path'
import { existsSync, mkdirSync } from 'fs'

// ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
const dataDir = join(process.cwd(), 'data')
if (!existsSync(dataDir)) {
  mkdirSync(dataDir, { recursive: true })
}

// åˆ›å»ºæ•°æ®åº“è¿æ¥
const dbPath = join(dataDir, 'travel.db')
export const db = new Database(dbPath)

// é…ç½®æ•°æ®åº“
db.pragma('journal_mode = WAL') // å¯ç”¨ WAL æ¨¡å¼
db.pragma('foreign_keys = ON')  // å¯ç”¨å¤–é”®çº¦æŸ
```

### 2. æ•°æ®åº“å·¥å…·å‡½æ•°

```typescript
// lib/db-utils.ts

// é€šç”¨æŸ¥è¯¢
export function dbQuery<T = any>(sql: string, params: any[] = []): T[] {
  try {
    const stmt = db.prepare(sql)
    return stmt.all(...params) as T[]
  } catch (error) {
    console.error('æŸ¥è¯¢é”™è¯¯:', error)
    throw error
  }
}

// æŸ¥è¯¢å•è¡Œ
export function dbGet<T = any>(sql: string, params: any[] = []): T | undefined {
  try {
    const stmt = db.prepare(sql)
    return stmt.get(...params) as T | undefined
  } catch (error) {
    console.error('æŸ¥è¯¢é”™è¯¯:', error)
    throw error
  }
}

// æ‰§è¡Œæ›´æ–°
export function dbRun(sql: string, params: any[] = []): { lastInsertRowid: number; changes: number } {
  try {
    const stmt = db.prepare(sql)
    const result = stmt.run(...params)
    return {
      lastInsertRowid: result.lastInsertRowid as number,
      changes: result.changes
    }
  } catch (error) {
    console.error('æ‰§è¡Œé”™è¯¯:', error)
    throw error
  }
}

// åˆ†é¡µæŸ¥è¯¢
export function paginate<T = any>(
  sql: string,
  page: number = 1,
  limit: number = 10,
  params: any[] = []
) {
  // è·å–æ€»æ•°
  const countSql = `SELECT COUNT(*) as total FROM (${sql})`
  const { total } = dbGet<{ total: number }>(countSql, params) || { total: 0 }

  // è·å–åˆ†é¡µæ•°æ®
  const offset = (page - 1) * limit
  const paginatedSql = `${sql} LIMIT ? OFFSET ?`
  const data = dbQuery<T>(paginatedSql, [...params, limit, offset])

  return {
    data,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  }
}

// äº‹åŠ¡å¤„ç†
export function dbTransaction<T>(callback: () => T): T {
  const transaction = db.transaction(callback)
  return transaction()
}
```

## ğŸ“ API è·¯ç”±å¼€å‘

### 1. åŸºç¡€è·¯ç”±ç»“æ„

```typescript
// app/api/example/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { validateAuth } from '@/lib/auth'
import { dbQuery, dbRun } from '@/lib/db-utils'

// GET è¯·æ±‚
export async function GET(request: NextRequest) {
  try {
    // è·å–æŸ¥è¯¢å‚æ•°
    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '10')

    // æ‰§è¡ŒæŸ¥è¯¢
    const sql = 'SELECT * FROM table_name ORDER BY created_at DESC'
    const result = paginate(sql, page, limit)

    return NextResponse.json({
      success: true,
      ...result
    })
  } catch (error) {
    console.error('Error:', error)
    return NextResponse.json(
      { success: false, error: 'æœåŠ¡å™¨é”™è¯¯' },
      { status: 500 }
    )
  }
}

// POST è¯·æ±‚
export async function POST(request: NextRequest) {
  try {
    // éªŒè¯ç”¨æˆ·èº«ä»½
    const { user, error } = validateAuth(request)
    if (!user) {
      return NextResponse.json(
        { success: false, error: error || 'æœªè®¤è¯' },
        { status: 401 }
      )
    }

    // è·å–è¯·æ±‚ä½“
    const body = await request.json()

    // éªŒè¯æ•°æ®
    if (!body.requiredField) {
      return NextResponse.json(
        { success: false, error: 'ç¼ºå°‘å¿…å¡«å­—æ®µ' },
        { status: 400 }
      )
    }

    // æ‰§è¡Œæ’å…¥
    const { lastInsertRowid } = dbRun(
      'INSERT INTO table_name (field1, field2) VALUES (?, ?)',
      [body.field1, body.field2]
    )

    // è¿”å›ç»“æœ
    return NextResponse.json({
      success: true,
      data: { id: lastInsertRowid, ...body },
      message: 'åˆ›å»ºæˆåŠŸ'
    })
  } catch (error) {
    console.error('Error:', error)
    return NextResponse.json(
      { success: false, error: 'åˆ›å»ºå¤±è´¥' },
      { status: 500 }
    )
  }
}
```

### 2. åŠ¨æ€è·¯ç”±

```typescript
// app/api/spots/[id]/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = params.id

    // æŸ¥è¯¢æ•°æ®
    const spot = dbGet(`
      SELECT s.*, c.name as category_name
      FROM spots s
      LEFT JOIN categories c ON s.category_id = c.id
      WHERE s.id = ?
    `, [id])

    if (!spot) {
      return NextResponse.json(
        { success: false, error: 'èµ„æºä¸å­˜åœ¨' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      success: true,
      data: spot
    })
  } catch (error) {
    console.error('Error:', error)
    return NextResponse.json(
      { success: false, error: 'è·å–å¤±è´¥' },
      { status: 500 }
    )
  }
}
```

### 3. å­è·¯ç”±

```typescript
// app/api/spots/[id]/comments/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const spotId = params.id
    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')

    // æŸ¥è¯¢è¯„è®º
    const sql = `
      SELECT c.*, u.full_name, u.avatar_url
      FROM comments c
      LEFT JOIN users u ON c.user_id = u.id
      WHERE c.spot_id = ?
      ORDER BY c.created_at DESC
    `

    const result = paginate(sql, page, 10, [spotId])

    return NextResponse.json({
      success: true,
      ...result
    })
  } catch (error) {
    console.error('Error:', error)
    return NextResponse.json(
      { success: false, error: 'è·å–è¯„è®ºå¤±è´¥' },
      { status: 500 }
    )
  }
}
```

## ğŸ” æ•°æ®éªŒè¯

### 1. ä½¿ç”¨ Zod éªŒè¯

```typescript
// lib/validations.ts
import { z } from 'zod'

// ç”¨æˆ·æ³¨å†ŒéªŒè¯
export const registerSchema = z.object({
  email: z.string().email('è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'),
  password: z.string().min(6, 'å¯†ç è‡³å°‘éœ€è¦ 6 ä½'),
  full_name: z.string().min(2, 'å§“åè‡³å°‘éœ€è¦ 2 ä¸ªå­—ç¬¦'),
  role: z.enum(['user', 'guide']).optional().default('user'),
})

// æ™¯ç‚¹åˆ›å»ºéªŒè¯
export const spotCreateSchema = z.object({
  name: z.string().min(1, 'æ™¯ç‚¹åç§°ä¸èƒ½ä¸ºç©º'),
  description: z.string().min(10, 'æè¿°è‡³å°‘éœ€è¦ 10 ä¸ªå­—ç¬¦'),
  category_id: z.number().int().positive('è¯·é€‰æ‹©æœ‰æ•ˆçš„åˆ†ç±»'),
  location: z.string().min(1, 'åœ°ç‚¹ä¸èƒ½ä¸ºç©º'),
  price: z.number().min(0, 'ä»·æ ¼ä¸èƒ½ä¸ºè´Ÿæ•°'),
  images: z.array(z.string().url()).optional().default([]),
})
```

### 2. åœ¨ API ä¸­ä½¿ç”¨éªŒè¯

```typescript
// app/api/spots/route.ts
import { spotCreateSchema } from '@/lib/validations'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    // éªŒè¯æ•°æ®
    const validatedData = spotCreateSchema.parse(body)

    // ç»§ç»­å¤„ç†...
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'æ•°æ®éªŒè¯å¤±è´¥',
          details: error.errors
        },
        { status: 400 }
      )
    }
    throw error
  }
}
```

## ğŸ” æƒé™æ§åˆ¶

### 1. æƒé™æ£€æŸ¥å‡½æ•°

```typescript
// lib/auth.ts
export function checkPermission(userRole: string, requiredRole: string): boolean {
  const roleHierarchy = {
    'admin': 3,
    'guide': 2,
    'user': 1
  }

  return roleHierarchy[userRole] >= roleHierarchy[requiredRole]
}

export function checkOwnership(user: User, resourceUserId: number): boolean {
  return user.id === resourceUserId || user.role === 'admin'
}
```

### 2. API æƒé™ä¸­é—´ä»¶

```typescript
// lib/api-middleware.ts
export function withAuth(handler: Function) {
  return async (request: NextRequest, ...args: any[]) => {
    const { user, error } = validateAuth(request)

    if (!user) {
      return NextResponse.json(
        { success: false, error: error || 'æœªè®¤è¯' },
        { status: 401 }
      )
    }

    return handler(request, user, ...args)
  }
}

export function withRole(requiredRole: string) {
  return function(handler: Function) {
    return async (request: NextRequest, user: User, ...args: any[]) => {
      if (!checkPermission(user.role, requiredRole)) {
        return NextResponse.json(
          { success: false, error: 'æƒé™ä¸è¶³' },
          { status: 403 }
        )
      }

      return handler(request, user, ...args)
    }
  }
}
```

### 3. ä½¿ç”¨æƒé™è£…é¥°å™¨

```typescript
// app/api/admin/protected/route.ts
import { withAuth, withRole } from '@/lib/api-middleware'

// éœ€è¦è®¤è¯å’Œç®¡ç†å‘˜æƒé™
export const GET = withAuth(withRole('admin')(async (request: NextRequest, user: User) => {
  // ç®¡ç†å‘˜åŠŸèƒ½
  return NextResponse.json({
    success: true,
    data: 'ç®¡ç†å‘˜æ•°æ®'
  })
}))
```

## ğŸ—„ï¸ æ•°æ®åº“æ“ä½œæœ€ä½³å®è·µ

### 1. ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢

```typescript
// âŒ é”™è¯¯ï¼šSQL æ³¨å…¥é£é™©
const sql = `SELECT * FROM users WHERE email = '${email}'`

// âœ… æ­£ç¡®ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
const user = dbGet('SELECT * FROM users WHERE email = ?', [email])
```

### 2. äº‹åŠ¡å¤„ç†

```typescript
// åˆ›å»ºè®¢å•å’Œå‡å°‘åº“å­˜
export function createOrder(userId: number, items: OrderItem[]) {
  return dbTransaction(() => {
    // åˆ›å»ºè®¢å•
    const { lastInsertRowid: orderId } = dbRun(
      'INSERT INTO orders (user_id, total_amount) VALUES (?, ?)',
      [userId, calculateTotal(items)]
    )

    // åˆ›å»ºè®¢å•é¡¹
    items.forEach(item => {
      dbRun(
        'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)',
        [orderId, item.productId, item.quantity, item.price]
      )

      // å‡å°‘åº“å­˜
      dbRun(
        'UPDATE products SET stock = stock - ? WHERE id = ?',
        [item.quantity, item.productId]
      )
    })

    return orderId
  })
}
```

### 3. æ‰¹é‡æ“ä½œ

```typescript
// æ‰¹é‡æ’å…¥
export function insertMultipleRecords(records: any[]) {
  const stmt = db.prepare(`
    INSERT INTO table_name (field1, field2, field3)
    VALUES (?, ?, ?)
  `)

  const transaction = db.transaction(() => {
    records.forEach(record => {
      stmt.run(record.field1, record.field2, record.field3)
    })
  })

  transaction()
}
```

## ğŸ“ é”™è¯¯å¤„ç†

### 1. è‡ªå®šä¹‰é”™è¯¯ç±»

```typescript
// lib/errors.ts
export class ApiError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

export class ValidationError extends ApiError {
  constructor(message: string, public details?: any) {
    super(message, 400, 'VALIDATION_ERROR')
  }
}

export class NotFoundError extends ApiError {
  constructor(resource: string) {
    super(`${resource} ä¸å­˜åœ¨`, 404, 'NOT_FOUND')
  }
}

export class UnauthorizedError extends ApiError {
  constructor(message: string = 'æœªæˆæƒ') {
    super(message, 401, 'UNAUTHORIZED')
  }
}
```

### 2. é”™è¯¯å¤„ç†ä¸­é—´ä»¶

```typescript
// lib/error-handler.ts
export function handleApiError(error: unknown): NextResponse {
  console.error('API Error:', error)

  if (error instanceof ApiError) {
    return NextResponse.json(
      {
        success: false,
        error: error.message,
        code: error.code
      },
      { status: error.statusCode }
    )
  }

  if (error instanceof z.ZodError) {
    return NextResponse.json(
      {
        success: false,
        error: 'æ•°æ®éªŒè¯å¤±è´¥',
        details: error.errors
      },
      { status: 400 }
    )
  }

  // é»˜è®¤é”™è¯¯
  return NextResponse.json(
    {
      success: false,
      error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
    },
    { status: 500 }
  )
}
```

### 3. åœ¨ API ä¸­ä½¿ç”¨

```typescript
// app/api/example/route.ts
export async function POST(request: NextRequest) {
  try {
    // ä¸šåŠ¡é€»è¾‘
    const result = await someOperation()

    return NextResponse.json({
      success: true,
      data: result
    })
  } catch (error) {
    return handleApiError(error)
  }
}
```

## ğŸ“Š æ—¥å¿—è®°å½•

### 1. æ—¥å¿—å·¥å…·

```typescript
// lib/logger.ts
type LogLevel = 'info' | 'warn' | 'error' | 'debug'

export class Logger {
  static log(level: LogLevel, message: string, data?: any) {
    const timestamp = new Date().toISOString()
    const log = {
      timestamp,
      level,
      message,
      data
    }

    console.log(JSON.stringify(log))

    // å¯ä»¥æ·»åŠ å†™å…¥æ–‡ä»¶çš„é€»è¾‘
  }

  static info(message: string, data?: any) {
    this.log('info', message, data)
  }

  static error(message: string, data?: any) {
    this.log('error', message, data)
  }
}
```

### 2. API æ—¥å¿—

```typescript
// app/api/middleware.ts
export function withLogging(handler: Function) {
  return async (request: NextRequest, ...args: any[]) => {
    const start = Date.now()
    const url = request.url

    Logger.info(`API Request: ${request.method} ${url}`)

    try {
      const response = await handler(request, ...args)

      const duration = Date.now() - start
      Logger.info(`API Response: ${request.method} ${url}`, {
        status: response.status,
        duration: `${duration}ms`
      })

      return response
    } catch (error) {
      Logger.error(`API Error: ${request.method} ${url}`, error)
      throw error
    }
  }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```typescript
// ä½¿ç”¨ç´¢å¼•
const spots = dbQuery(`
  SELECT * FROM spots
  WHERE category_id = ? AND status = 1
  ORDER BY created_at DESC
  LIMIT 10
`, [categoryId])

// é¿å… N+1 æŸ¥è¯¢
const spotsWithCategories = dbQuery(`
  SELECT
    s.*,
    c.name as category_name
  FROM spots s
  LEFT JOIN categories c ON s.category_id = c.id
  WHERE s.status = 1
`)

// ä½¿ç”¨èšåˆæŸ¥è¯¢
const spotStats = dbQuery(`
  SELECT
    s.id,
    s.name,
    COUNT(DISTINCT l.id) as like_count,
    COUNT(DISTINCT f.id) as favorite_count,
    AVG(c.rating) as average_rating
  FROM spots s
  LEFT JOIN spot_likes l ON s.id = l.spot_id
  LEFT JOIN spot_favorites f ON s.id = f.spot_id
  LEFT JOIN spot_comments c ON s.id = c.spot_id
  GROUP BY s.id
`)
```

### 2. ç¼“å­˜ç­–ç•¥

```typescript
// lib/cache.ts
const cache = new Map<string, { data: any; timestamp: number }>()
const CACHE_TTL = 5 * 60 * 1000 // 5 åˆ†é’Ÿ

export function getFromCache<T>(key: string): T | null {
  const cached = cache.get(key)
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data
  }
  return null
}

export function setCache<T>(key: string, data: T): void {
  cache.set(key, {
    data,
    timestamp: Date.now()
  })
}

// åœ¨ API ä¸­ä½¿ç”¨ç¼“å­˜
export async function getCategories() {
  const cacheKey = 'categories'
  let categories = getFromCache<Category[]>(cacheKey)

  if (!categories) {
    categories = dbQuery('SELECT * FROM spot_categories ORDER BY sort_order')
    setCache(cacheKey, categories)
  }

  return categories
}
```

### 3. åˆ†é¡µä¼˜åŒ–

```typescript
// ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µå¤„ç†å¤§æ•°æ®é›†
export function getCursorPaginatedResults(cursor?: number, limit = 10) {
  let sql = 'SELECT * FROM table_name'
  const params: any[] = []

  if (cursor) {
    sql += ' WHERE id < ?'
    params.push(cursor)
  }

  sql += ' ORDER BY id DESC LIMIT ?'
  params.push(limit + 1) // å¤šè·å–ä¸€æ¡åˆ¤æ–­æ˜¯å¦æœ‰ä¸‹ä¸€é¡µ

  const results = dbQuery(sql, params)
  const hasMore = results.length > limit
  const data = hasMore ? results.slice(0, -1) : results

  return {
    data,
    hasMore,
    nextCursor: data.length > 0 ? data[data.length - 1].id : null
  }
}
```

## ğŸ“ æµ‹è¯•

### 1. API æµ‹è¯•

```typescript
// tests/api/spots.test.ts
import { createMocks } from 'node-mocks-http'
import handler from '@/app/api/spots/route'

describe('/api/spots', () => {
  it('should return spots list', async () => {
    const { req, res } = createMocks({ method: 'GET' })

    await handler(req, res)

    expect(res._getStatusCode()).toBe(200)
    const data = JSON.parse(res._getData())
    expect(data.success).toBe(true)
    expect(Array.isArray(data.data)).toBe(true)
  })
})
```

### 2. æ•°æ®åº“æµ‹è¯•

```typescript
// tests/db/utils.test.ts
import { initDatabase, closeDatabase } from '@/lib/db'
import { dbQuery, dbRun } from '@/lib/db-utils'

beforeAll(async () => {
  await initDatabase()
})

afterAll(async () => {
  closeDatabase()
})

test('should insert and retrieve data', () => {
  const { lastInsertRowid } = dbRun(
    'INSERT INTO test_table (name) VALUES (?)',
    ['test']
  )

  const result = dbGet('SELECT * FROM test_table WHERE id = ?', [lastInsertRowid])
  expect(result.name).toBe('test')
})
```

## ğŸ”§ å¼€å‘å·¥å…·

### 1. API æ–‡æ¡£ç”Ÿæˆ

```typescript
// scripts/generate-api-docs.mjs
import { readdirSync } from 'fs'
import { join } from 'path'

function extractApiEndpoints() {
  const apiDir = join(process.cwd(), 'app', 'api')
  const endpoints = []

  function scanDirectory(dir: string, prefix = '') {
    const items = readdirSync(dir)

    for (const item of items) {
      const fullPath = join(dir, item)
      const stat = fs.statSync(fullPath)

      if (stat.isDirectory()) {
        scanDirectory(fullPath, `${prefix}/${item}`)
      } else if (item === 'route.ts') {
        // è§£æè·¯ç”±æ–‡ä»¶
        const endpoint = {
          path: `/api${prefix}`,
          methods: []
        }
        endpoints.push(endpoint)
      }
    }
  }

  scanDirectory(apiDir)
  return endpoints
}
```

### 2. æ•°æ®åº“è¿ç§»å·¥å…·

```typescript
// scripts/migrate.mjs
import { readFileSync, writeFileSync } from 'fs'
import { db } from '../lib/db'

function runMigration(filename: string) {
  const sql = readFileSync(join(process.cwd(), 'migrations', filename), 'utf8')

  try {
    db.exec(sql)
    console.log(`Migration ${filename} completed`)
  } catch (error) {
    console.error(`Migration ${filename} failed:`, error)
  }
}

// è¿è¡Œæ‰€æœ‰æœªæ‰§è¡Œçš„è¿ç§»
const migrations = readdirSync('migrations').sort()
for (const migration of migrations) {
  runMigration(migration)
}
```

---

è¿™ä»½æŒ‡å—æ¶µç›–äº†åç«¯å¼€å‘çš„å„ä¸ªæ–¹é¢ï¼Œéµå¾ªè¿™äº›è§„èŒƒå¯ä»¥å¸®åŠ©æ‚¨æ„å»ºå¥å£®ã€é«˜æ•ˆçš„åç«¯æœåŠ¡ã€‚